{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./_scripts/index.js","webpack:///./node_modules/svelte-slabs-renderer/index.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAqD;AACrD;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAI,iEAAuB;AAC3B,KAAK;AACL,GAAG;AACH,CAAC;;;;;;;;;;;;;;;AC1CD;AAAA;AAAA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,gDAAgD;AAC/E,GAAG;AACH,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA,C","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./_scripts/index.js\");\n","import * as svelteSlabs from \"svelte-slabs-renderer\";\n;\n\n/**\n * Convert a component path (like in bookshop) to a component name.\n * Removes duplicate file/folder name, stops at components folder or dotpath.\n * @param  {String} filepath Raw filepath that was imported\n * @return {String}          Component name, as per bookshop conventions\n */\nconst rewriteSvelteComponent = (filepath) => {\n  const fp = filepath.toLowerCase().split('/').reverse();\n  const componentName = [fp[0].replace(/\\..*$/, '')];\n  const startAt = fp[1] === componentName[0] ? 2 : 1;\n  for (let i = startAt; i < fp.length; i++) {\n    if (fp[i] === 'components') break;\n    if (/\\./.test(fp[i])) break;\n    componentName.unshift(fp[i]);\n  }\n  return componentName.join('/');\n};\n\n/**\n * Turn a raw import-glob-keyed object into a map of components\n * @param  {Object} importedObj Output from import-glob-keyed\n * @param  {Object} appObj      Object to insert components into\n */\nconst mapSvelteFiles = (importedObj, appObj) => {\n\tfor (let [file, component] of Object.entries(importedObj)) {\n\t\tfile = rewriteSvelteComponent(file);\n\t\tappObj[file] = component.default ? component.default : component;\n\t}\n}\n\n(function() {\n  import(/* webpackIgnore: true */ \"/assets/site/components.js\").then(m => {\n    const usableApps = {};\n    if (window.bookshop_components) mapSvelteFiles(window.bookshop_components.default, usableApps);\n    if (typeof THEME_COMPONENTS !== 'undefined') mapSvelteFiles(THEME_COMPONENTS, usableApps);\n\n    svelteSlabs.renderSlabs(usableApps, {\n    })\n  })\n}());\n\n\n","/**\n * Find props for a slab based on the given propstring\n * @param  {String} propString String defining where to locate the svelte props\n * @return {Object}            Props ready to pass to svelte\n */\nconst resolveProps = (propString) => {\n\tif (!propString) return {};\n\tconst [src, key] = propString.split(':');\n\tif (src === 'window') {\n\t\tif (!window.svelteSlabs) return {};\n\t\treturn window.svelteSlabs[key] || {};\n\t} else if (src === 'endpoint') {\n\t\tconsole.warn('Endpoints not yet supported');\n\t\treturn {};\n\t}\n}\n\n/**\n * Look for svelte tags on the page, and try render an app into them.\n * @param  {Object} apps    All svelte components available, keyed by name\n * @return {Object}         All svelte apps that were rendered on the page\n */\nexport const renderSlabs = (apps, opts) => {\n\topts = {\n\t\thydrate: true,\n\t\t...opts\n\t}\n\n\tconst renderTargets = document.querySelectorAll(\"[data-svelte-slab]\");\n\tconst renderedSlabs = [];\n\n\tfor (const target of renderTargets) {\n\t\tconst slabName = target.dataset.svelteSlab;\n\t\tconst slabPropsKey = target.dataset.svelteSlabProps;\n\n\t\tconst app = apps[slabName];\n\t\tif (app) {\n\t\t\tconst slabProps = resolveProps(slabPropsKey);\n\t\t\tif (typeof opts.transformProps === 'function') {\n\t\t\t\topts.transformProps(slabProps);\n\t\t\t}\n\n\t\t\trenderedSlabs.push(new app({target, props: slabProps, hydrate: opts.hydrate}));\n\t\t} else {\n\t\t\tconsole.warn(`WARN: Svelte slab \"${slabName}\" not found`)\n\t\t}\n\t}\n\n\treturn renderedSlabs;\n}"],"sourceRoot":""}